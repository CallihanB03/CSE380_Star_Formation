        -:    0:Source:src/hydro.cpp
        -:    0:Source is newer than graph
        -:    1:#include "../include/hydro.hpp"
        -:    2:#include <cmath>
        -:    3:#include <algorithm>
        -:    4:
        -:    5:#ifndef M_PI
        -:    6:#define M_PI 3.14159265358979323846
        -:    7:#endif
        -:    8:
        -:    9:// cubic spline kernel derivative dW/dr for 3D; returns dWdr
function _ZL17cubic_spline_dWdrff called 0 returned 0% blocks executed 0%
    #####:   10:static inline float cubic_spline_dWdr(float r, float h) {
    #####:   11:    const float q = r / h;
    #####:   12:    const float inv_h4 = 1.0f / (h*h*h*h);
    #####:   13:    const float sigma = 1.0f / (M_PI) * inv_h4; // normalization for derivative in 3D
    #####:   14:    if (r <= 0.0f) return 0.0f;
    %%%%%:   14-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:   14-block  1
unconditional  2 never executed
    #####:   15:    if (q < 1.0f) {
    %%%%%:   15-block  0
branch  0 never executed
branch  1 never executed
        -:   16:        // d/dr [1 - 1.5 q^2 + 0.75 q^3] = (-3 q + (9/4) q^2) * (1/h)
    #####:   17:        return sigma * (-3.0f * q + 2.25f * q * q);
    %%%%%:   17-block  0
unconditional  0 never executed
    #####:   18:    } else if (q < 2.0f) {
    %%%%%:   18-block  0
branch  0 never executed
branch  1 never executed
    #####:   19:        float t = 2.0f - q;
        -:   20:        // d/dr[0.25 t^3] = 0.25 * 3 * t^2 * (-1/h) = -0.75 * t^2 / h
    #####:   21:        return sigma * (-0.75f * t * t);
    %%%%%:   21-block  0
unconditional  0 never executed
        -:   22:    } else {
    #####:   23:        return 0.0f;
    %%%%%:   23-block  0
unconditional  0 never executed
        -:   24:    }
        -:   25:}
        -:   26:
function _Z16compute_pressureR9Particlesff called 0 returned 0% blocks executed 0%
    #####:   27:void compute_pressure(Particles& P, float K, float gamma) {
    #####:   28:    size_t N = P.N;
    #####:   29:    if (P.pressure.size() != N) P.pressure.assign(N, 0.0f);
    %%%%%:   29-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    %%%%%:   29-block  1
call    3 never executed
branch  4 never executed
branch  5 never executed
    %%%%%:   29-block  2
unconditional  6 never executed
    #####:   30:    for (size_t i = 0; i < N; ++i) {
    %%%%%:   30-block  0
unconditional  0 never executed
    %%%%%:   30-block  1
branch  1 never executed
branch  2 never executed
        -:   31:        // polytropic EOS (robust for collapse tests)
    #####:   32:        float rho = std::max(P.density[i], 1e-12f);
    %%%%%:   32-block  0
call    0 never executed
call    1 never executed
    #####:   33:        P.pressure[i] = K * std::pow(rho, gamma);
call    0 never executed
call    1 never executed
unconditional  2 never executed
        -:   34:    }
    #####:   35:}
    %%%%%:   35-block  0
unconditional  0 never executed
        -:   36:
        -:   37:// Optimization 3
function _Z23compute_pressure_forcesR9ParticlesfRSt6vectorIfSaIfEES4_S4_ called 0 returned 0% blocks executed 0%
    #####:   38:// Computes SPH pressure forces: a_i = sum_j -m_j (P_i/rho_i^2 + P_j/rho_j^2) grad W_ij
        -:   39:void compute_pressure_forces(
        -:   40:    Particles& P,
        -:   41:    float h,
        -:   42:    std::vector<float>& ax,
        -:   43:    std::vector<float>& ay,
        -:   44:    std::vector<float>& az
    #####:   45:) {
        -:   46:    size_t N = P.N;
        -:   47:
    #####:   48:    // resize acceleration vectors if needed
    %%%%%:   48-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    %%%%%:   48-block  1
call    3 never executed
branch  4 never executed
branch  5 never executed
    %%%%%:   48-block  2
unconditional  6 never executed
    $$$$$:   48-block  3
unconditional  7 never executed
    #####:   49:    if (ax.size() != N) ax.assign(N, 0.0f);
    %%%%%:   49-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    %%%%%:   49-block  1
call    3 never executed
branch  4 never executed
branch  5 never executed
    %%%%%:   49-block  2
unconditional  6 never executed
    $$$$$:   49-block  3
unconditional  7 never executed
    #####:   50:    if (ay.size() != N) ay.assign(N, 0.0f);
    %%%%%:   50-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    %%%%%:   50-block  1
call    3 never executed
branch  4 never executed
branch  5 never executed
    %%%%%:   50-block  2
unconditional  6 never executed
    $$$$$:   50-block  3
unconditional  7 never executed
        -:   51:    if (az.size() != N) az.assign(N, 0.0f);
        -:   52:
    #####:   53:    // small epsilon to avoid division by zero
        -:   54:    const float eps = 1e-12f;
        -:   55:
    #####:   56:    // pairwise loop
    %%%%%:   56-block  0
unconditional  0 never executed
    %%%%%:   56-block  1
unconditional  1 never executed
    %%%%%:   56-block  2
branch  2 never executed
branch  3 never executed
    #####:   57:    for (size_t i = 0; i < N; ++i) {
    %%%%%:   57-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    %%%%%:   57-block  1
unconditional  3 never executed
        -:   58:        if (!P.alive[i]) continue;
    #####:   59:
    %%%%%:   59-block  0
call    0 never executed
call    1 never executed
    #####:   60:        float rho_i = std::max(P.density[i], eps);
    #####:   61:        float rho_i2_inv = 1.0f / (rho_i * rho_i);
call    0 never executed
        -:   62:        float P_i_rho2 = P.pressure[i] * rho_i2_inv;
    #####:   63:
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:   64:        float xi = P.x[i]; float yi = P.y[i]; float zi = P.z[i];
    #####:   65:
unconditional  0 never executed
    %%%%%:   65-block  0
unconditional  1 never executed
    %%%%%:   65-block  1
branch  2 never executed
branch  3 never executed
    #####:   66:        // Vec3 xi(P.x[i], P.y[i], P.z[i]);
    %%%%%:   66-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    %%%%%:   66-block  1
unconditional  3 never executed
    %%%%%:   66-block  2
unconditional  4 never executed
        -:   67:
    #####:   68:        for (size_t j = i + 1; j < N; ++j) {
    %%%%%:   68-block  0
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
    #####:   69:            if (!P.alive[j]) continue;
call    0 never executed
    #####:   70:
call    0 never executed
    #####:   71:            // Vec3 xj(P.x[j], P.y[j], P.z[j]);
call    0 never executed
        -:   72:
    #####:   73:            float xj = P.x[j]; float yj = P.y[j]; float zj = P.z[j];
branch  0 never executed
branch  1 never executed
    %%%%%:   73-block  0
branch  2 never executed
branch  3 never executed
    %%%%%:   73-block  1
unconditional  4 never executed
        -:   74:
    #####:   75:            // Vec3 dx = xj - xi;
    %%%%%:   75-block  0
call    0 never executed
    #####:   76:            float dx = (xj - xi); float dy = (yj - yi); float dz = (zj - zi);
branch  0 never executed
branch  1 never executed
    %%%%%:   76-block  0
unconditional  2 never executed
        -:   77:            float r = std::sqrt( dx*dx + dy*dy + dz*dz );
    #####:   78:            // float r2 = dx.length2();
    %%%%%:   78-block  0
call    0 never executed
call    1 never executed
    #####:   79:            // float r = std::sqrt(r2);
    #####:   80:
call    0 never executed
        -:   81:            if (r > 2.0f * h || r < eps) continue;
    #####:   82:
call    0 never executed
        -:   83:            float dWdr = cubic_spline_dWdr(r, h);
    #####:   84:            if (dWdr == 0.0f) continue;
call    0 never executed
    #####:   85:
call    0 never executed
        -:   86:            float rho_j = std::max(P.density[j], eps);
        -:   87:            float rho_j2_inv = 1.0f / (rho_j * rho_j);
    #####:   88:            float P_j_rho2 = P.pressure[j] * rho_j2_inv;
call    0 never executed
    #####:   89:
call    0 never executed
    #####:   90:            float term = -P.mass[j] * (P_i_rho2 + P_j_rho2);
call    0 never executed
        -:   91:
    #####:   92:            // Vec3 gradW = dx * (dWdr / r); // grad W_ij
call    0 never executed
    #####:   93:            // Vec3 a = gradW * term;
call    0 never executed
    #####:   94:
call    0 never executed
unconditional  1 never executed
        -:   95:            float grad_scalar = (dWdr / r);
        -:   96:            float grad_x = dx * grad_scalar;
    #####:   97:            float grad_y = dy * grad_scalar;
    %%%%%:   97-block  0
unconditional  0 never executed
        -:   98:            float grad_z = dz * grad_scalar;
        -:   99:
        -:  100:            float a_x = grad_x * term;
        -:  101:            float a_y = grad_y * term;
        -:  102:            float a_z = grad_z * term;
        -:  103:
        -:  104:            // symmetric update (momentum conserved)
        -:  105:            // ax[i] += a.x;
        -:  106:            // ay[i] += a.y;
        -:  107:            // az[i] += a.z;
        -:  108:
        -:  109:            // ax[j] -= a.x;
        -:  110:            // ay[j] -= a.y;
        -:  111:            // az[j] -= a.z;
        -:  112:
        -:  113:            // symmetric update (momentum conserved)
        -:  114:            ax[i] += a_x;
        -:  115:            ay[i] += a_y;
        -:  116:            az[i] += a_z;
        -:  117:
        -:  118:            ax[j] -= a_x;
        -:  119:            ay[j] -= a_y;
        -:  120:            az[j] -= a_z;
        -:  121:        }
        -:  122:    }
        -:  123:}
        -:  124:
        -:  125:// This is where the thermodynamics and kinetics kiss
        -:  126:// void compute_pressure_forces_cached(
        -:  127://     Particles& P,
        -:  128://     float h
        -:  129:// ) {
        -:  130://     size_t N = P.N;
        -:  131:
        -:  132://     // small epsilon to avoid division by zero
        -:  133://     const float eps = 1e-12f;
        -:  134:
        -:  135://     // pairwise loop
        -:  136://     for (size_t i = 0; i < N; ++i) {
        -:  137://         if (!P.alive[i]) continue;
        -:  138:
        -:  139://         float rho_i = std::max(P.density[i], eps);
        -:  140://         float rho_i2_inv = 1.0f / (rho_i * rho_i);
        -:  141://         float P_i_rho2 = P.pressure[i] * rho_i2_inv;
        -:  142:
        -:  143://         float xi = P.x[i]; float yi = P.y[i]; float zi = P.z[i];
        -:  144:
        -:  145://         for (size_t j = i + 1; j < N; ++j) {
        -:  146://             if (!P.alive[j]) continue;
        -:  147:
        -:  148://             float xj = P.x[j]; float yj = P.y[j]; float zj = P.z[j];
        -:  149:
        -:  150://             float dx = (xj - xi); float dy = (yj - yi); float dz = (zj - zi);
        -:  151://             float r = std::sqrt( dx*dx + dy*dy + dz*dz );
        -:  152:
        -:  153://             if (r > 2.0f * h || r < eps) continue;
        -:  154:
        -:  155://             float dWdr = cubic_spline_dWdr(r, h);
        -:  156://             if (dWdr == 0.0f) continue;
        -:  157:
        -:  158://             float rho_j = std::max(P.density[j], eps);
        -:  159://             float rho_j2_inv = 1.0f / (rho_j * rho_j);
        -:  160://             float P_j_rho2 = P.pressure[j] * rho_j2_inv;
        -:  161:
        -:  162://             float term = -P.mass[j] * (P_i_rho2 + P_j_rho2);
        -:  163:
        -:  164://             float grad_scalar = (dWdr / r);
        -:  165://             float grad_x = dx * grad_scalar;
        -:  166://             float grad_y = dy * grad_scalar;
        -:  167://             float grad_z = dz * grad_scalar;
        -:  168:
        -:  169://             float a_x = grad_x * term;
        -:  170://             float a_y = grad_y * term;
        -:  171://             float a_z = grad_z * term;
        -:  172:
        -:  173://             // symmetric update (momentum conserved)
        -:  174://             P.ax[i] += a_x;
        -:  175://             P.ay[i] += a_y;
        -:  176://             P.az[i] += a_z;
        -:  177:
        -:  178://             P.ax[j] -= a_x;
        -:  179://             P.ay[j] -= a_y;
        -:  180://             P.az[j] -= a_z;
        -:  181://         }
        -:  182://     }
        -:  183:// }
        -:  184:
        -:  185:void compute_pressure_forces_cached(
        -:  186:    Particles& P,
        -:  187:    float h
        -:  188:) {
        -:  189:    size_t N = P.N;
        -:  190:
        -:  191:    // read-only pointers
        -:  192:    const float* x  = P.x.data();
        -:  193:    const float* y  = P.y.data();
        -:  194:    const float* z  = P.z.data();
        -:  195:    const float* rho = P.density.data();
        -:  196:    const float* pres = P.pressure.data();
        -:  197:    const float* mass = P.mass.data();
        -:  198:    const uint8_t* alive = P.alive.data();
        -:  199:
        -:  200:    // writable acceleration pointers
        -:  201:    float* ax = P.ax.data();
        -:  202:    float* ay = P.ay.data();
        -:  203:    float* az = P.az.data();
        -:  204:
        -:  205:    const float eps = 1e-12f;
        -:  206:
        -:  207:    for (size_t i = 0; i < N; ++i) {
        -:  208:        if (!alive[i]) continue;
        -:  209:
        -:  210:        float rho_i = std::max(rho[i], eps);
        -:  211:        float rho_i2_inv = 1.0f / (rho_i * rho_i);
        -:  212:        float P_i_rho2 = pres[i] * rho_i2_inv;
        -:  213:
        -:  214:        float xi = x[i], yi = y[i], zi = z[i];
        -:  215:
        -:  216:        for (size_t j = i + 1; j < N; ++j) {
        -:  217:            if (!alive[j]) continue;
        -:  218:
        -:  219:            float dx = x[j] - xi;
        -:  220:            float dy = y[j] - yi;
        -:  221:            float dz = z[j] - zi;
        -:  222:            float r = std::sqrt(dx*dx + dy*dy + dz*dz);
        -:  223:
        -:  224:            if (r > 2.0f*h || r < eps) continue;
        -:  225:
        -:  226:            float dWdr = cubic_spline_dWdr(r, h);
        -:  227:            if (dWdr == 0.0f) continue;
        -:  228:
        -:  229:            float rho_j = std::max(rho[j], eps);
        -:  230:            float rho_j2_inv = 1.0f / (rho_j * rho_j);
        -:  231:            float P_j_rho2 = pres[j] * rho_j2_inv;
        -:  232:
        -:  233:            float term = -mass[j] * (P_i_rho2 + P_j_rho2);
        -:  234:
        -:  235:            float grad = dWdr / r;
        -:  236:
        -:  237:            float a_x = dx * grad * term;
        -:  238:            float a_y = dy * grad * term;
        -:  239:            float a_z = dz * grad * term;
        -:  240:
        -:  241:            ax[i] += a_x;
        -:  242:            ay[i] += a_y;
        -:  243:            az[i] += a_z;
        -:  244:
        -:  245:            ax[j] -= a_x;
        -:  246:            ay[j] -= a_y;
        -:  247:            az[j] -= a_z;
        -:  248:        }
        -:  249:    }
        -:  250:}
