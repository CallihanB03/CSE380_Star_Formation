        -:    0:Source:src/hydro.cpp
        -:    1:#include "../include/hydro.hpp"
        -:    2:#include <cmath>
        -:    3:#include <algorithm>
        -:    4:
        -:    5:#ifndef M_PI
        -:    6:#define M_PI 3.14159265358979323846
        -:    7:#endif
        -:    8:
        -:    9:// cubic spline kernel derivative dW/dr for 3D; returns dWdr
    #####:   10:static inline float cubic_spline_dWdr(float r, float h) {
    #####:   11:    const float q = r / h;
    #####:   12:    const float inv_h4 = 1.0f / (h*h*h*h);
    #####:   13:    const float sigma = 1.0f / (M_PI) * inv_h4; // normalization for derivative in 3D
    #####:   14:    if (r <= 0.0f) return 0.0f;
    #####:   15:    if (q < 1.0f) {
        -:   16:        // d/dr [1 - 1.5 q^2 + 0.75 q^3] = (-3 q + (9/4) q^2) * (1/h)
    #####:   17:        return sigma * (-3.0f * q + 2.25f * q * q);
    #####:   18:    } else if (q < 2.0f) {
    #####:   19:        float t = 2.0f - q;
        -:   20:        // d/dr[0.25 t^3] = 0.25 * 3 * t^2 * (-1/h) = -0.75 * t^2 / h
    #####:   21:        return sigma * (-0.75f * t * t);
        -:   22:    } else {
    #####:   23:        return 0.0f;
        -:   24:    }
        -:   25:}
        -:   26:
    #####:   27:void compute_pressure(Particles& P, float K, float gamma) {
    #####:   28:    size_t N = P.N;
    #####:   29:    if (P.pressure.size() != N) P.pressure.assign(N, 0.0f);
    #####:   30:    for (size_t i = 0; i < N; ++i) {
        -:   31:        // polytropic EOS (robust for collapse tests)
    #####:   32:        float rho = std::max(P.density[i], 1e-12f);
    #####:   33:        P.pressure[i] = K * std::pow(rho, gamma);
        -:   34:    }
    #####:   35:}
        -:   36:
        -:   37:// Computes SPH pressure forces: a_i = sum_j -m_j (P_i/rho_i^2 + P_j/rho_j^2) grad W_ij
    #####:   38:void compute_pressure_forces(
        -:   39:    Particles& P,
        -:   40:    float h,
        -:   41:    std::vector<float>& ax,
        -:   42:    std::vector<float>& ay,
        -:   43:    std::vector<float>& az
        -:   44:) {
    #####:   45:    size_t N = P.N;
        -:   46:
        -:   47:    // resize acceleration vectors if needed
    #####:   48:    if (ax.size() != N) ax.assign(N, 0.0f);
    #####:   49:    if (ay.size() != N) ay.assign(N, 0.0f);
    #####:   50:    if (az.size() != N) az.assign(N, 0.0f);
        -:   51:
        -:   52:    // small epsilon to avoid division by zero
    #####:   53:    const float eps = 1e-12f;
        -:   54:
        -:   55:    // pairwise loop
    #####:   56:    for (size_t i = 0; i < N; ++i) {
    #####:   57:        if (!P.alive[i]) continue;
        -:   58:
    #####:   59:        float rho_i = std::max(P.density[i], eps);
    #####:   60:        float rho_i2_inv = 1.0f / (rho_i * rho_i);
    #####:   61:        float P_i_rho2 = P.pressure[i] * rho_i2_inv;
        -:   62:
    #####:   63:        Vec3 xi(P.x[i], P.y[i], P.z[i]);
        -:   64:
    #####:   65:        for (size_t j = i + 1; j < N; ++j) {
    #####:   66:            if (!P.alive[j]) continue;
        -:   67:
    #####:   68:            Vec3 xj(P.x[j], P.y[j], P.z[j]);
    #####:   69:            Vec3 dx = xj - xi;
    #####:   70:            float r2 = dx.length2();
    #####:   71:            float r = std::sqrt(r2);
        -:   72:
    #####:   73:            if (r > 2.0f * h || r < eps) continue;
        -:   74:
    #####:   75:            float dWdr = cubic_spline_dWdr(r, h);
    #####:   76:            if (dWdr == 0.0f) continue;
        -:   77:
    #####:   78:            float rho_j = std::max(P.density[j], eps);
    #####:   79:            float rho_j2_inv = 1.0f / (rho_j * rho_j);
    #####:   80:            float P_j_rho2 = P.pressure[j] * rho_j2_inv;
        -:   81:
    #####:   82:            float term = -P.mass[j] * (P_i_rho2 + P_j_rho2);
        -:   83:
    #####:   84:            Vec3 gradW = dx * (dWdr / r); // grad W_ij
    #####:   85:            Vec3 a = gradW * term;
        -:   86:
        -:   87:            // symmetric update (momentum conserved)
    #####:   88:            ax[i] += a.x;
    #####:   89:            ay[i] += a.y;
    #####:   90:            az[i] += a.z;
        -:   91:
    #####:   92:            ax[j] -= a.x;
    #####:   93:            ay[j] -= a.y;
    #####:   94:            az[j] -= a.z;
        -:   95:        }
        -:   96:    }
    #####:   97:}
